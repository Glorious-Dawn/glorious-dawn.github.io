{"version":3,"sources":["../webpack/bootstrap","cv/tracking.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","Strings.js","cv/MatchWorker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","tracking","EventEmitter","events_","addListener","event","listener","TypeError","this","emit","push","listeners","args","Array","slice","arguments","length","apply","on","once","self","handlerInternal","removeListener","removeAllListeners","opt_event","isArray","indexOf","splice","setMaxListeners","Error","Canvas","loadImage","canvas","src","x","y","width","height","opt_callback","instance","img","window","Image","crossOrigin","onload","context","getContext","drawImage","DisjointSet","undefined","parent","Uint32Array","find","union","j","iRepresentative","jRepresentative","blur","pixels","diameter","Math","abs","radius","len","ceil","weights","Float32Array","rho","rhoSq","gaussianFactor","sqrt","PI","rhoFactor","wsum","middle","floor","gx","exp","separableConvolve","computeIntegralImage","opt_integralImage","opt_integralImageSquare","opt_tiltedIntegralImage","opt_integralImageSobel","pixelsSobel","sobel","w","pixel","computePixelValueSAT_","w1","pixelAbove","computePixelValueRSAT_","RSAT","SAT","grayscale","fillRGBA","gray","Uint8ClampedArray","horizontalConvolve","weightsVector","opaque","side","halfSide","output","alphaFac","sy","sx","offset","g","b","a","cx","poffset","min","max","wt","verticalConvolve","cy","horizWeights","vertWeights","vertical","sobelSignVector","sobelScaleVector","horizontal","v","h","ViolaJones","REGIONS_OVERLAP","classifiers","detect","initialScale","scaleFactor","stepSize","edgesDensity","data","integralImageSobel","total","rects","integralImage","Int32Array","integralImageSquare","tiltedIntegralImage","minWidth","minHeight","scale","blockWidth","blockHeight","step","isTriviallyExcluded","evalStages_","mergeRectangles_","wbA","wbB","wbD","wbC","inverseArea","mean","variance","standardDeviation","stageSum","stageThreshold","nodeLength","rectsSum","tilted","rectsLength","w2","w3","w4","rectLeft","rectTop","rectWidth","rectHeight","rectWeight","nodeThreshold","nodeLeft","nodeRight","disjointSet","r1","r2","intersectRect","x1","y1","overlap","area1","area2","map","k","rep","result","keys","forEach","rect","Brief","N","randomImageOffsets_","randomWindowOffsets_","getDescriptors","keypoints","descriptors","descriptorWord","offsets","getRandomOffsets_","position","offsetsPosition","match","keypoints1","descriptors1","keypoints2","descriptors2","len1","len2","matches","Infinity","minj","dist","hammingWeight","index1","index2","keypoint1","keypoint2","confidence","reciprocalMatch","matches1","matches2","windowPosition","windowOffsets","round","uniformRandom","imagePosition","imageOffsets","Fast","THRESHOLD","circles_","findCorners","opt_threshold","circleOffsets","getCircleOffsets_","circlePixels","corners","isCorner","isBrighter","circlePixel","threshold","darker","brighter","isDarker","count","circleBottom","circleLeft","circleRight","circleTop","circle","distance","x0","y0","dx","dy","random","x2","y2","x3","y3","Matrix","fn","opt_jump","EPnP","solve","objectPoints","imagePoints","cameraMatrix","from","setRandomWindowOffsets","generateRandomWindowOffsets","_arrayLikeToArray","arr","arr2","_createForOfIteratorHelper","iterator","minLen","toString","constructor","test","F","done","e","_e","f","it","err","normalCompletion","didErr","next","_e2","mainImageCorners","mainImageDescriptors","matchOnMain","feature","filter","onmessage","op","reply","Strings","windowOffset","subImageId","imageData","extractFeature","batchResult","postMessage"],"mappings":"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GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,IAAI,GAAG,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,IAAI,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,GAAG,EAAE,IAAI,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,IAAI,EAAE,EAAE,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,IAAI,IAAI,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,IAAI,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,IAAI,IAAI,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,IAAI,GAAG,IAAI,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI,EAAE,EAAE,IAAI,IAAI,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,IAAI,IAAI,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,IAAI,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,IAAI,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,IAAI,IAAI,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,IAAI,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,IAAI,GAAG,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,IAAI,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,IAAI,IAAI,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,IAAI,EAAE,EAAE,GAAG,IAAI,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,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","file":"6b51f71c40d54e09dcb6.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/* eslint-disable */\r\n/**\r\n * tracking - A modern approach for Computer Vision on the web.\r\n * @author Eduardo Lundgren <edu@rdo.io>\r\n * @version v1.1.2\r\n * @link http://trackingjs.com\r\n * @license BSD\r\n */\r\nlet tracking={};\r\n\r\n(function() {\r\n  /**\r\n   * EventEmitter utility.\r\n   * @constructor\r\n   */\r\n  tracking.EventEmitter = function() {};\r\n\r\n  /**\r\n   * Holds event listeners scoped by event type.\r\n   * @type {object}\r\n   * @private\r\n   */\r\n  tracking.EventEmitter.prototype.events_ = null;\r\n\r\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  tracking.EventEmitter.prototype.addListener = function(event, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('Listener must be a function');\r\n    }\r\n    if (!this.events_) {\r\n      this.events_ = {};\r\n    }\r\n\r\n    this.emit('newListener', event, listener);\r\n\r\n    if (!this.events_[event]) {\r\n      this.events_[event] = [];\r\n    }\r\n\r\n    this.events_[event].push(listener);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Returns an array of listeners for the specified event.\r\n   * @param {string} event\r\n   * @return {array} Array of listeners.\r\n   */\r\n  tracking.EventEmitter.prototype.listeners = function(event) {\r\n    return this.events_ && this.events_[event];\r\n  };\r\n\r\n  /**\r\n   * Execute each of the listeners in order with the supplied arguments.\r\n   * @param {string} event\r\n   * @param {*} opt_args [arg1], [arg2], [...]\r\n   * @return {boolean} Returns true if event had listeners, false otherwise.\r\n   */\r\n  tracking.EventEmitter.prototype.emit = function(event) {\r\n    var listeners = this.listeners(event);\r\n    if (listeners) {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      for (var i = 0; i < listeners.length; i++) {\r\n        if (listeners[i]) {\r\n          listeners[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Adds a listener to the end of the listeners array for the specified event.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  tracking.EventEmitter.prototype.on = tracking.EventEmitter.prototype.addListener;\r\n\r\n  /**\r\n   * Adds a one time listener for the event. This listener is invoked only the\r\n   * next time the event is fired, after which it is removed.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  tracking.EventEmitter.prototype.once = function(event, listener) {\r\n    var self = this;\r\n    self.on(event, function handlerInternal() {\r\n      self.removeListener(event, handlerInternal);\r\n      listener.apply(this, arguments);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Removes all listeners, or those of the specified event. It's not a good\r\n   * idea to remove listeners that were added elsewhere in the code,\r\n   * especially when it's on an emitter that you didn't create.\r\n   * @param {string} event\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  tracking.EventEmitter.prototype.removeAllListeners = function(opt_event) {\r\n    if (!this.events_) {\r\n      return this;\r\n    }\r\n    if (opt_event) {\r\n      delete this.events_[opt_event];\r\n    } else {\r\n      delete this.events_;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Remove a listener from the listener array for the specified event.\r\n   * Caution: changes array indices in the listener array behind the listener.\r\n   * @param {string} event\r\n   * @param {function} listener\r\n   * @return {object} Returns emitter, so calls can be chained.\r\n   */\r\n  tracking.EventEmitter.prototype.removeListener = function(event, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('Listener must be a function');\r\n    }\r\n    if (!this.events_) {\r\n      return this;\r\n    }\r\n\r\n    var listeners = this.listeners(event);\r\n    if (Array.isArray(listeners)) {\r\n      var i = listeners.indexOf(listener);\r\n      if (i < 0) {\r\n        return this;\r\n      }\r\n      listeners.splice(i, 1);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * By default EventEmitters will print a warning if more than 10 listeners\r\n   * are added for a particular event. This is a useful default which helps\r\n   * finding memory leaks. Obviously not all Emitters should be limited to 10.\r\n   * This function allows that to be increased. Set to zero for unlimited.\r\n   * @param {number} n The maximum number of listeners.\r\n   */\r\n  tracking.EventEmitter.prototype.setMaxListeners = function() {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Canvas utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Canvas = {};\r\n\r\n  /**\r\n   * Loads an image source into the canvas.\r\n   * @param {HTMLCanvasElement} canvas The canvas dom element.\r\n   * @param {string} src The image source.\r\n   * @param {number} x The canvas horizontal coordinate to load the image.\r\n   * @param {number} y The canvas vertical coordinate to load the image.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} opt_callback Callback that fires when the image is loaded\r\n   *     into the canvas.\r\n   * @static\r\n   */\r\n  tracking.Canvas.loadImage = function(canvas, src, x, y, width, height, opt_callback) {\r\n    var instance = this;\r\n    var img = new window.Image();\r\n    img.crossOrigin = '*';\r\n    img.onload = function() {\r\n      var context = canvas.getContext('2d');\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      context.drawImage(img, x, y, width, height);\r\n      if (opt_callback) {\r\n        opt_callback.call(instance);\r\n      }\r\n      img = null;\r\n    };\r\n    img.src = src;\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * DisjointSet utility with path compression. Some applications involve\r\n   * grouping n distinct objects into a collection of disjoint sets. Two\r\n   * important operations are then finding which set a given object belongs to\r\n   * and uniting the two sets. A disjoint set data structure maintains a\r\n   * collection S={ S1 , S2 ,..., Sk } of disjoint dynamic sets. Each set is\r\n   * identified by a representative, which usually is a member in the set.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.DisjointSet = function(length) {\r\n    if (length === undefined) {\r\n      throw new Error('DisjointSet length not specified.');\r\n    }\r\n    this.length = length;\r\n    this.parent = new Uint32Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      this.parent[i] = i;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Holds the length of the internal set.\r\n   * @type {number}\r\n   */\r\n  tracking.DisjointSet.prototype.length = null;\r\n\r\n  /**\r\n   * Holds the set containing the representative values.\r\n   * @type {Array.<number>}\r\n   */\r\n  tracking.DisjointSet.prototype.parent = null;\r\n\r\n  /**\r\n   * Finds a pointer to the representative of the set containing i.\r\n   * @param {number} i\r\n   * @return {number} The representative set of i.\r\n   */\r\n  tracking.DisjointSet.prototype.find = function(i) {\r\n    if (this.parent[i] === i) {\r\n      return i;\r\n    } else {\r\n      return (this.parent[i] = this.find(this.parent[i]));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unites two dynamic sets containing objects i and j, say Si and Sj, into\r\n   * a new set that Si ∪ Sj, assuming that Si ∩ Sj = ∅;\r\n   * @param {number} i\r\n   * @param {number} j\r\n   */\r\n  tracking.DisjointSet.prototype.union = function(i, j) {\r\n    var iRepresentative = this.find(i);\r\n    var jRepresentative = this.find(j);\r\n    this.parent[iRepresentative] = jRepresentative;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Image utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Image = {};\r\n\r\n  /**\r\n   * Computes gaussian blur. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} diameter Gaussian blur diameter, must be greater than 1.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  tracking.Image.blur = function(pixels, width, height, diameter) {\r\n    diameter = Math.abs(diameter);\r\n    if (diameter <= 1) {\r\n      throw new Error('Diameter should be greater than 1.');\r\n    }\r\n    var radius = diameter / 2;\r\n    var len = Math.ceil(diameter) + (1 - (Math.ceil(diameter) % 2));\r\n    var weights = new Float32Array(len);\r\n    var rho = (radius + 0.5) / 3;\r\n    var rhoSq = rho * rho;\r\n    var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\r\n    var rhoFactor = -1 / (2 * rho * rho);\r\n    var wsum = 0;\r\n    var middle = Math.floor(len / 2);\r\n    for (var i = 0; i < len; i++) {\r\n      var x = i - middle;\r\n      var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\r\n      weights[i] = gx;\r\n      wsum += gx;\r\n    }\r\n    for (var j = 0; j < weights.length; j++) {\r\n      weights[j] /= wsum;\r\n    }\r\n    return this.separableConvolve(pixels, width, height, weights, weights, false);\r\n  };\r\n\r\n  /**\r\n   * Computes the integral image for summed, squared, rotated and sobel pixels.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} opt_integralImage Empty array of size `width * height` to\r\n   *     be filled with the integral image values. If not specified compute sum\r\n   *     values will be skipped.\r\n   * @param {array} opt_integralImageSquare Empty array of size `width *\r\n   *     height` to be filled with the integral image squared values. If not\r\n   *     specified compute squared values will be skipped.\r\n   * @param {array} opt_tiltedIntegralImage Empty array of size `width *\r\n   *     height` to be filled with the rotated integral image values. If not\r\n   *     specified compute sum values will be skipped.\r\n   * @param {array} opt_integralImageSobel Empty array of size `width *\r\n   *     height` to be filled with the integral image of sobel values. If not\r\n   *     specified compute sobel filtering will be skipped.\r\n   * @static\r\n   */\r\n  tracking.Image.computeIntegralImage = function(pixels, width, height, opt_integralImage, opt_integralImageSquare, opt_tiltedIntegralImage, opt_integralImageSobel) {\r\n    if (arguments.length < 4) {\r\n      throw new Error('You should specify at least one output array in the order: sum, square, tilted, sobel.');\r\n    }\r\n    var pixelsSobel;\r\n    if (opt_integralImageSobel) {\r\n      pixelsSobel = tracking.Image.sobel(pixels, width, height);\r\n    }\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var w = i * width * 4 + j * 4;\r\n        var pixel = ~~(pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114);\r\n        if (opt_integralImage) {\r\n          this.computePixelValueSAT_(opt_integralImage, width, i, j, pixel);\r\n        }\r\n        if (opt_integralImageSquare) {\r\n          this.computePixelValueSAT_(opt_integralImageSquare, width, i, j, pixel * pixel);\r\n        }\r\n        if (opt_tiltedIntegralImage) {\r\n          var w1 = w - width * 4;\r\n          var pixelAbove = ~~(pixels[w1] * 0.299 + pixels[w1 + 1] * 0.587 + pixels[w1 + 2] * 0.114);\r\n          this.computePixelValueRSAT_(opt_tiltedIntegralImage, width, i, j, pixel, pixelAbove || 0);\r\n        }\r\n        if (opt_integralImageSobel) {\r\n          this.computePixelValueSAT_(opt_integralImageSobel, width, i, j, pixelsSobel[w]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Helper method to compute the rotated summed area table (RSAT) by the\r\n   * formula:\r\n   *\r\n   * RSAT(x, y) = RSAT(x-1, y-1) + RSAT(x+1, y-1) - RSAT(x, y-2) + I(x, y) + I(x, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} RSAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\r\n  tracking.Image.computePixelValueRSAT_ = function(RSAT, width, i, j, pixel, pixelAbove) {\r\n    var w = i * width + j;\r\n    RSAT[w] = (RSAT[w - width - 1] || 0) + (RSAT[w - width + 1] || 0) - (RSAT[w - width - width] || 0) + pixel + pixelAbove;\r\n  };\r\n\r\n  /**\r\n   * Helper method to compute the summed area table (SAT) by the formula:\r\n   *\r\n   * SAT(x, y) = SAT(x, y-1) + SAT(x-1, y) + I(x, y) - SAT(x-1, y-1)\r\n   *\r\n   * @param {number} width The image width.\r\n   * @param {array} SAT Empty array of size `width * height` to be filled with\r\n   *     the integral image values. If not specified compute sum values will be\r\n   *     skipped.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} pixel Pixel value to be added to the integral image.\r\n   * @static\r\n   * @private\r\n   */\r\n  tracking.Image.computePixelValueSAT_ = function(SAT, width, i, j, pixel) {\r\n    var w = i * width + j;\r\n    SAT[w] = (SAT[w - width] || 0) + (SAT[w - 1] || 0) + pixel - (SAT[w - width - 1] || 0);\r\n  };\r\n\r\n  /**\r\n   * Converts a color from a colorspace based on an RGB color model to a\r\n   * grayscale representation of its luminance. The coefficients represent the\r\n   * measured intensity perception of typical trichromat humans, in\r\n   * particular, human vision is most sensitive to green and least sensitive\r\n   * to blue.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {boolean} fillRGBA If the result should fill all RGBA values with the gray scale\r\n   *  values, instead of returning a single value per pixel.\r\n   * @param {Uint8ClampedArray} The grayscale pixels in a linear array ([p,p,p,a,...] if fillRGBA\r\n   *  is true and [p1, p2, p3, ...] if fillRGBA is false).\r\n   * @static\r\n   */\r\n  tracking.Image.grayscale = function(pixels, width, height, fillRGBA) {\r\n    var gray = new Uint8ClampedArray(fillRGBA ? pixels.length : pixels.length >> 2);\r\n    var p = 0;\r\n    var w = 0;\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var value = pixels[w] * 0.299 + pixels[w + 1] * 0.587 + pixels[w + 2] * 0.114;\r\n        gray[p++] = value;\r\n\r\n        if (fillRGBA) {\r\n          gray[p++] = value;\r\n          gray[p++] = value;\r\n          gray[p++] = pixels[w + 3];\r\n        }\r\n\r\n        w += 4;\r\n      }\r\n    }\r\n    return gray;\r\n  };\r\n\r\n  /**\r\n   * Fast horizontal separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  tracking.Image.horizontalConvolve = function(pixels, width, height, weightsVector, opaque) {\r\n    var side = weightsVector.length;\r\n    var halfSide = Math.floor(side / 2);\r\n    var output = new Float32Array(width * height * 4);\r\n    var alphaFac = opaque ? 1 : 0;\r\n\r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        var sy = y;\r\n        var sx = x;\r\n        var offset = (y * width + x) * 4;\r\n        var r = 0;\r\n        var g = 0;\r\n        var b = 0;\r\n        var a = 0;\r\n        for (var cx = 0; cx < side; cx++) {\r\n          var scy = sy;\r\n          var scx = Math.min(width - 1, Math.max(0, sx + cx - halfSide));\r\n          var poffset = (scy * width + scx) * 4;\r\n          var wt = weightsVector[cx];\r\n          r += pixels[poffset] * wt;\r\n          g += pixels[poffset + 1] * wt;\r\n          b += pixels[poffset + 2] * wt;\r\n          a += pixels[poffset + 3] * wt;\r\n        }\r\n        output[offset] = r;\r\n        output[offset + 1] = g;\r\n        output[offset + 2] = b;\r\n        output[offset + 3] = a + alphaFac * (255 - a);\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * Fast vertical separable convolution. A point spread function (PSF) is\r\n   * said to be separable if it can be broken into two one-dimensional\r\n   * signals: a vertical and a horizontal projection. The convolution is\r\n   * performed by sliding the kernel over the image, generally starting at the\r\n   * top left corner, so as to move the kernel through all the positions where\r\n   * the kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} weightsVector The weighting vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  tracking.Image.verticalConvolve = function(pixels, width, height, weightsVector, opaque) {\r\n    var side = weightsVector.length;\r\n    var halfSide = Math.floor(side / 2);\r\n    var output = new Float32Array(width * height * 4);\r\n    var alphaFac = opaque ? 1 : 0;\r\n\r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        var sy = y;\r\n        var sx = x;\r\n        var offset = (y * width + x) * 4;\r\n        var r = 0;\r\n        var g = 0;\r\n        var b = 0;\r\n        var a = 0;\r\n        for (var cy = 0; cy < side; cy++) {\r\n          var scy = Math.min(height - 1, Math.max(0, sy + cy - halfSide));\r\n          var scx = sx;\r\n          var poffset = (scy * width + scx) * 4;\r\n          var wt = weightsVector[cy];\r\n          r += pixels[poffset] * wt;\r\n          g += pixels[poffset + 1] * wt;\r\n          b += pixels[poffset + 2] * wt;\r\n          a += pixels[poffset + 3] * wt;\r\n        }\r\n        output[offset] = r;\r\n        output[offset + 1] = g;\r\n        output[offset + 2] = b;\r\n        output[offset + 3] = a + alphaFac * (255 - a);\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * Fast separable convolution. A point spread function (PSF) is said to be\r\n   * separable if it can be broken into two one-dimensional signals: a\r\n   * vertical and a horizontal projection. The convolution is performed by\r\n   * sliding the kernel over the image, generally starting at the top left\r\n   * corner, so as to move the kernel through all the positions where the\r\n   * kernel fits entirely within the boundaries of the image. Adapted from\r\n   * https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {array} horizWeights The horizontal weighting vector, e.g [-1,0,1].\r\n   * @param {array} vertWeights The vertical vector, e.g [-1,0,1].\r\n   * @param {number} opaque\r\n   * @return {array} The convoluted pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  tracking.Image.separableConvolve = function(pixels, width, height, horizWeights, vertWeights, opaque) {\r\n    var vertical = this.verticalConvolve(pixels, width, height, vertWeights, opaque);\r\n    return this.horizontalConvolve(vertical, width, height, horizWeights, opaque);\r\n  };\r\n\r\n  /**\r\n   * Compute image edges using Sobel operator. Computes the vertical and\r\n   * horizontal gradients of the image and combines the computed images to\r\n   * find edges in the image. The way we implement the Sobel filter here is by\r\n   * first grayscaling the image, then taking the horizontal and vertical\r\n   * gradients and finally combining the gradient images to make up the final\r\n   * image. Adapted from https://github.com/kig/canvasfilters.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @return {array} The edge pixels in a linear [r,g,b,a,...] array.\r\n   */\r\n  tracking.Image.sobel = function(pixels, width, height) {\r\n    pixels = this.grayscale(pixels, width, height, true);\r\n    var output = new Float32Array(width * height * 4);\r\n    var sobelSignVector = new Float32Array([-1, 0, 1]);\r\n    var sobelScaleVector = new Float32Array([1, 2, 1]);\r\n    var vertical = this.separableConvolve(pixels, width, height, sobelSignVector, sobelScaleVector);\r\n    var horizontal = this.separableConvolve(pixels, width, height, sobelScaleVector, sobelSignVector);\r\n\r\n    for (var i = 0; i < output.length; i += 4) {\r\n      var v = vertical[i];\r\n      var h = horizontal[i];\r\n      var p = Math.sqrt(h * h + v * v);\r\n      output[i] = p;\r\n      output[i + 1] = p;\r\n      output[i + 2] = p;\r\n      output[i + 3] = 255;\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * ViolaJones utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.ViolaJones = {};\r\n\r\n  /**\r\n   * Holds the minimum area of intersection that defines when a rectangle is\r\n   * from the same group. Often when a face is matched multiple rectangles are\r\n   * classified as possible rectangles to represent the face, when they\r\n   * intersects they are grouped as one face.\r\n   * @type {number}\r\n   * @default 0.5\r\n   * @static\r\n   */\r\n  tracking.ViolaJones.REGIONS_OVERLAP = 0.5;\r\n\r\n  /**\r\n   * Holds the HAAR cascade classifiers converted from OpenCV training.\r\n   * @type {array}\r\n   * @static\r\n   */\r\n  tracking.ViolaJones.classifiers = {};\r\n\r\n  /**\r\n   * Detects through the HAAR cascade data rectangles matches.\r\n   * @param {pixels} pixels The pixels in a linear [r,g,b,a,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} initialScale The initial scale to start the block\r\n   *     scaling.\r\n   * @param {number} scaleFactor The scale factor to scale the feature block.\r\n   * @param {number} stepSize The block step size.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block. Value from [0.0, 1.0], defaults to 0.2. If specified\r\n   *     edge detection will be applied to the image to prune dead areas of the\r\n   *     image, this can improve significantly performance.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @return {array} Found rectangles.\r\n   * @static\r\n   */\r\n  tracking.ViolaJones.detect = function(pixels, width, height, initialScale, scaleFactor, stepSize, edgesDensity, data) {\r\n    var total = 0;\r\n    var rects = [];\r\n    var integralImage = new Int32Array(width * height);\r\n    var integralImageSquare = new Int32Array(width * height);\r\n    var tiltedIntegralImage = new Int32Array(width * height);\r\n\r\n    var integralImageSobel;\r\n    if (edgesDensity > 0) {\r\n      integralImageSobel = new Int32Array(width * height);\r\n    }\r\n\r\n    tracking.Image.computeIntegralImage(pixels, width, height, integralImage, integralImageSquare, tiltedIntegralImage, integralImageSobel);\r\n\r\n    var minWidth = data[0];\r\n    var minHeight = data[1];\r\n    var scale = initialScale * scaleFactor;\r\n    var blockWidth = (scale * minWidth) | 0;\r\n    var blockHeight = (scale * minHeight) | 0;\r\n\r\n    while (blockWidth < width && blockHeight < height) {\r\n      var step = (scale * stepSize + 0.5) | 0;\r\n      for (var i = 0; i < (height - blockHeight); i += step) {\r\n        for (var j = 0; j < (width - blockWidth); j += step) {\r\n\r\n          if (edgesDensity > 0) {\r\n            if (this.isTriviallyExcluded(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight)) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (this.evalStages_(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale)) {\r\n            rects[total++] = {\r\n              width: blockWidth,\r\n              height: blockHeight,\r\n              x: j,\r\n              y: i\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      scale *= scaleFactor;\r\n      blockWidth = (scale * minWidth) | 0;\r\n      blockHeight = (scale * minHeight) | 0;\r\n    }\r\n    return this.mergeRectangles_(rects);\r\n  };\r\n\r\n  /**\r\n   * Fast check to test whether the edges density inside the block is greater\r\n   * than a threshold, if true it tests the stages. This can improve\r\n   * significantly performance.\r\n   * @param {number} edgesDensity Percentage density edges inside the\r\n   *     classifier block.\r\n   * @param {array} integralImageSobel The integral image of a sobel image.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @return {boolean} True whether the block at position i,j can be skipped,\r\n   *     false otherwise.\r\n   * @static\r\n   * @protected\r\n   */\r\n  tracking.ViolaJones.isTriviallyExcluded = function(edgesDensity, integralImageSobel, i, j, width, blockWidth, blockHeight) {\r\n    var wbA = i * width + j;\r\n    var wbB = wbA + blockWidth;\r\n    var wbD = wbA + blockHeight * width;\r\n    var wbC = wbD + blockWidth;\r\n    var blockEdgesDensity = (integralImageSobel[wbA] - integralImageSobel[wbB] - integralImageSobel[wbD] + integralImageSobel[wbC]) / (blockWidth * blockHeight * 255);\r\n    if (blockEdgesDensity < edgesDensity) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Evaluates if the block size on i,j position is a valid HAAR cascade\r\n   * stage.\r\n   * @param {number} data The HAAR cascade data.\r\n   * @param {number} i Vertical position of the pixel to be evaluated.\r\n   * @param {number} j Horizontal position of the pixel to be evaluated.\r\n   * @param {number} width The image width.\r\n   * @param {number} blockSize The block size.\r\n   * @param {number} scale The scale factor of the block size and its original\r\n   *     size.\r\n   * @param {number} inverseArea The inverse area of the block size.\r\n   * @return {boolean} Whether the region passes all the stage tests.\r\n   * @private\r\n   * @static\r\n   */\r\n  tracking.ViolaJones.evalStages_ = function(data, integralImage, integralImageSquare, tiltedIntegralImage, i, j, width, blockWidth, blockHeight, scale) {\r\n    var inverseArea = 1.0 / (blockWidth * blockHeight);\r\n    var wbA = i * width + j;\r\n    var wbB = wbA + blockWidth;\r\n    var wbD = wbA + blockHeight * width;\r\n    var wbC = wbD + blockWidth;\r\n    var mean = (integralImage[wbA] - integralImage[wbB] - integralImage[wbD] + integralImage[wbC]) * inverseArea;\r\n    var variance = (integralImageSquare[wbA] - integralImageSquare[wbB] - integralImageSquare[wbD] + integralImageSquare[wbC]) * inverseArea - mean * mean;\r\n\r\n    var standardDeviation = 1;\r\n    if (variance > 0) {\r\n      standardDeviation = Math.sqrt(variance);\r\n    }\r\n\r\n    var length = data.length;\r\n\r\n    for (var w = 2; w < length; ) {\r\n      var stageSum = 0;\r\n      var stageThreshold = data[w++];\r\n      var nodeLength = data[w++];\r\n\r\n      while (nodeLength--) {\r\n        var rectsSum = 0;\r\n        var tilted = data[w++];\r\n        var rectsLength = data[w++];\r\n\r\n        for (var r = 0; r < rectsLength; r++) {\r\n          var rectLeft = (j + data[w++] * scale + 0.5) | 0;\r\n          var rectTop = (i + data[w++] * scale + 0.5) | 0;\r\n          var rectWidth = (data[w++] * scale + 0.5) | 0;\r\n          var rectHeight = (data[w++] * scale + 0.5) | 0;\r\n          var rectWeight = data[w++];\r\n\r\n          var w1;\r\n          var w2;\r\n          var w3;\r\n          var w4;\r\n          if (tilted) {\r\n            // RectSum(r) = RSAT(x-h+w, y+w+h-1) + RSAT(x, y-1) - RSAT(x-h, y+h-1) - RSAT(x+w, y+w-1)\r\n            w1 = (rectLeft - rectHeight + rectWidth) + (rectTop + rectWidth + rectHeight - 1) * width;\r\n            w2 = rectLeft + (rectTop - 1) * width;\r\n            w3 = (rectLeft - rectHeight) + (rectTop + rectHeight - 1) * width;\r\n            w4 = (rectLeft + rectWidth) + (rectTop + rectWidth - 1) * width;\r\n            rectsSum += (tiltedIntegralImage[w1] + tiltedIntegralImage[w2] - tiltedIntegralImage[w3] - tiltedIntegralImage[w4]) * rectWeight;\r\n          } else {\r\n            // RectSum(r) = SAT(x-1, y-1) + SAT(x+w-1, y+h-1) - SAT(x-1, y+h-1) - SAT(x+w-1, y-1)\r\n            w1 = rectTop * width + rectLeft;\r\n            w2 = w1 + rectWidth;\r\n            w3 = w1 + rectHeight * width;\r\n            w4 = w3 + rectWidth;\r\n            rectsSum += (integralImage[w1] - integralImage[w2] - integralImage[w3] + integralImage[w4]) * rectWeight;\r\n            // w1 = (rectLeft - 1) + (rectTop - 1) * width;\r\n            // w2 = (rectLeft + rectWidth - 1) + (rectTop + rectHeight - 1) * width;\r\n            // w3 = (rectLeft - 1) + (rectTop + rectHeight - 1) * width;\r\n            // w4 = (rectLeft + rectWidth - 1) + (rectTop - 1) * width;\r\n            // rectsSum += (integralImage[w1] + integralImage[w2] - integralImage[w3] - integralImage[w4]) * rectWeight;\r\n          }\r\n        }\r\n\r\n        var nodeThreshold = data[w++];\r\n        var nodeLeft = data[w++];\r\n        var nodeRight = data[w++];\r\n\r\n        if (rectsSum * inverseArea < nodeThreshold * standardDeviation) {\r\n          stageSum += nodeLeft;\r\n        } else {\r\n          stageSum += nodeRight;\r\n        }\r\n      }\r\n\r\n      if (stageSum < stageThreshold) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Postprocess the detected sub-windows in order to combine overlapping\r\n   * detections into a single detection.\r\n   * @param {array} rects\r\n   * @return {array}\r\n   * @private\r\n   * @static\r\n   */\r\n  tracking.ViolaJones.mergeRectangles_ = function(rects) {\r\n    var disjointSet = new tracking.DisjointSet(rects.length);\r\n\r\n    for (var i = 0; i < rects.length; i++) {\r\n      var r1 = rects[i];\r\n      for (var j = 0; j < rects.length; j++) {\r\n        var r2 = rects[j];\r\n        if (tracking.Math.intersectRect(r1.x, r1.y, r1.x + r1.width, r1.y + r1.height, r2.x, r2.y, r2.x + r2.width, r2.y + r2.height)) {\r\n          var x1 = Math.max(r1.x, r2.x);\r\n          var y1 = Math.max(r1.y, r2.y);\r\n          var x2 = Math.min(r1.x + r1.width, r2.x + r2.width);\r\n          var y2 = Math.min(r1.y + r1.height, r2.y + r2.height);\r\n          var overlap = (x1 - x2) * (y1 - y2);\r\n          var area1 = (r1.width * r1.height);\r\n          var area2 = (r2.width * r2.height);\r\n\r\n          if ((overlap / (area1 * (area1 / area2)) >= this.REGIONS_OVERLAP) &&\r\n            (overlap / (area2 * (area1 / area2)) >= this.REGIONS_OVERLAP)) {\r\n            disjointSet.union(i, j);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var map = {};\r\n    for (var k = 0; k < disjointSet.length; k++) {\r\n      var rep = disjointSet.find(k);\r\n      if (!map[rep]) {\r\n        map[rep] = {\r\n          total: 1,\r\n          width: rects[k].width,\r\n          height: rects[k].height,\r\n          x: rects[k].x,\r\n          y: rects[k].y\r\n        };\r\n        continue;\r\n      }\r\n      map[rep].total++;\r\n      map[rep].width += rects[k].width;\r\n      map[rep].height += rects[k].height;\r\n      map[rep].x += rects[k].x;\r\n      map[rep].y += rects[k].y;\r\n    }\r\n\r\n    var result = [];\r\n    Object.keys(map).forEach(function(key) {\r\n      var rect = map[key];\r\n      result.push({\r\n        total: rect.total,\r\n        width: (rect.width / rect.total + 0.5) | 0,\r\n        height: (rect.height / rect.total + 0.5) | 0,\r\n        x: (rect.x / rect.total + 0.5) | 0,\r\n        y: (rect.y / rect.total + 0.5) | 0\r\n      });\r\n    });\r\n\r\n    return result;\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Brief intends for \"Binary Robust Independent Elementary Features\".This\r\n   * method generates a binary string for each keypoint found by an extractor\r\n   * method.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Brief = {};\r\n\r\n  /**\r\n   * The set of binary tests is defined by the nd (x,y)-location pairs\r\n   * uniquely chosen during the initialization. Values could vary between N =\r\n   * 128,256,512. N=128 yield good compromises between speed, storage\r\n   * efficiency, and recognition rate.\r\n   * @type {number}\r\n   */\r\n  tracking.Brief.N = 512;\r\n\r\n  /**\r\n   * Caches coordinates values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\r\n  tracking.Brief.randomImageOffsets_ = {};\r\n\r\n  /**\r\n   * Caches delta values of (x,y)-location pairs uniquely chosen during\r\n   * the initialization.\r\n   * @type {Int32Array}\r\n   * @private\r\n   * @static\r\n   */\r\n  tracking.Brief.randomWindowOffsets_ = null;\r\n\r\n  /**\r\n   * Generates a binary string for each found keypoints extracted using an\r\n   * extractor method.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {array} keypoints\r\n   * @return {Int32Array} Returns an array where for each four sequence int\r\n   *     values represent the descriptor binary string (128 bits) necessary\r\n   *     to describe the corner, e.g. [0,0,0,0, 0,0,0,0, ...].\r\n   * @static\r\n   */\r\n  tracking.Brief.getDescriptors = function(pixels, width, keypoints) {\r\n    // Optimizing divide by 32 operation using binary shift\r\n    // (this.N >> 5) === this.N/32.\r\n    var descriptors = new Int32Array((keypoints.length >> 1) * (this.N >> 5));\r\n    var descriptorWord = 0;\r\n    var offsets = this.getRandomOffsets_(width);\r\n    var position = 0;\r\n\r\n    for (var i = 0; i < keypoints.length; i += 2) {\r\n      var w = width * keypoints[i + 1] + keypoints[i];\r\n\r\n      var offsetsPosition = 0;\r\n      for (var j = 0, n = this.N; j < n; j++) {\r\n        if (pixels[offsets[offsetsPosition++] + w] < pixels[offsets[offsetsPosition++] + w]) {\r\n          // The bit in the position `j % 32` of descriptorWord should be set to 1. We do\r\n          // this by making an OR operation with a binary number that only has the bit\r\n          // in that position set to 1. That binary number is obtained by shifting 1 left by\r\n          // `j % 32` (which is the same as `j & 31` left) positions.\r\n          descriptorWord |= 1 << (j & 31);\r\n        }\r\n\r\n        // If the next j is a multiple of 32, we will need to use a new descriptor word to hold\r\n        // the next results.\r\n        if (!((j + 1) & 31)) {\r\n          descriptors[position++] = descriptorWord;\r\n          descriptorWord = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    return descriptors;\r\n  };\r\n\r\n  /**\r\n   * Matches sets of features {mi} and {m′j} extracted from two images taken\r\n   * from similar, and often successive, viewpoints. A classical procedure\r\n   * runs as follows. For each point {mi} in the first image, search in a\r\n   * region of the second image around location {mi} for point {m′j}. The\r\n   * search is based on the similarity of the local image windows, also known\r\n   * as kernel windows, centered on the points, which strongly characterizes\r\n   * the points when the images are sufficiently close. Once each keypoint is\r\n   * described with its binary string, they need to be compared with the\r\n   * closest matching point. Distance metric is critical to the performance of\r\n   * in- trusion detection systems. Thus using binary strings reduces the size\r\n   * of the descriptor and provides an interesting data structure that is fast\r\n   * to operate whose similarity can be measured by the Hamming distance.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\r\n  tracking.Brief.match = function(keypoints1, descriptors1, keypoints2, descriptors2) {\r\n    var len1 = keypoints1.length >> 1;\r\n    var len2 = keypoints2.length >> 1;\r\n    var matches = new Array(len1);\r\n\r\n    for (var i = 0; i < len1; i++) {\r\n      var min = Infinity;\r\n      var minj = 0;\r\n      for (var j = 0; j < len2; j++) {\r\n        var dist = 0;\r\n        // Optimizing divide by 32 operation using binary shift\r\n        // (this.N >> 5) === this.N/32.\r\n        for (var k = 0, n = this.N >> 5; k < n; k++) {\r\n          dist += tracking.Math.hammingWeight(descriptors1[i * n + k] ^ descriptors2[j * n + k]);\r\n        }\r\n        if (dist < min) {\r\n          min = dist;\r\n          minj = j;\r\n        }\r\n      }\r\n      matches[i] = {\r\n        index1: i,\r\n        index2: minj,\r\n        keypoint1: [keypoints1[2 * i], keypoints1[2 * i + 1]],\r\n        keypoint2: [keypoints2[2 * minj], keypoints2[2 * minj + 1]],\r\n        confidence: 1 - min / this.N\r\n      };\r\n    }\r\n\r\n    return matches;\r\n  };\r\n\r\n  /**\r\n   * Removes matches outliers by testing matches on both directions.\r\n   * @param {array} keypoints1\r\n   * @param {array} descriptors1\r\n   * @param {array} keypoints2\r\n   * @param {array} descriptors2\r\n   * @return {Int32Array} Returns an array where the index is the corner1\r\n   *     index coordinate, and the value is the corresponding match index of\r\n   *     corner2, e.g. keypoints1=[x0,y0,x1,y1,...] and\r\n   *     keypoints2=[x'0,y'0,x'1,y'1,...], if x0 matches x'1 and x1 matches x'0,\r\n   *     the return array would be [3,0].\r\n   * @static\r\n   */\r\n  tracking.Brief.reciprocalMatch = function(keypoints1, descriptors1, keypoints2, descriptors2) {\r\n    var matches = [];\r\n    if (keypoints1.length === 0 || keypoints2.length === 0) {\r\n      return matches;\r\n    }\r\n\r\n    var matches1 = tracking.Brief.match(keypoints1, descriptors1, keypoints2, descriptors2);\r\n    var matches2 = tracking.Brief.match(keypoints2, descriptors2, keypoints1, descriptors1);\r\n    for (var i = 0; i < matches1.length; i++) {\r\n      if (matches2[matches1[i].index2].index2 === i) {\r\n        matches.push(matches1[i]);\r\n      }\r\n    }\r\n    return matches;\r\n  };\r\n\r\n  /**\r\n   * Gets the coordinates values of (x,y)-location pairs uniquely chosen\r\n   * during the initialization.\r\n   * @return {array} Array with the random offset values.\r\n   * @private\r\n   */\r\n  tracking.Brief.getRandomOffsets_ = function(width) {\r\n    if (!this.randomWindowOffsets_) {\r\n      var windowPosition = 0;\r\n      var windowOffsets = new Int32Array(4 * this.N);\r\n      for (var i = 0; i < this.N; i++) {\r\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n        windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n      }\r\n      this.randomWindowOffsets_ = windowOffsets;\r\n    }\r\n\r\n    if (!this.randomImageOffsets_[width]) {\r\n      var imagePosition = 0;\r\n      var imageOffsets = new Int32Array(2 * this.N);\r\n      for (var j = 0; j < this.N; j++) {\r\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j] * width + this.randomWindowOffsets_[4 * j + 1];\r\n        imageOffsets[imagePosition++] = this.randomWindowOffsets_[4 * j + 2] * width + this.randomWindowOffsets_[4 * j + 3];\r\n      }\r\n      this.randomImageOffsets_[width] = imageOffsets;\r\n    }\r\n\r\n    return this.randomImageOffsets_[width];\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * FAST intends for \"Features from Accelerated Segment Test\". This method\r\n   * performs a point segment test corner detection. The segment test\r\n   * criterion operates by considering a circle of sixteen pixels around the\r\n   * corner candidate p. The detector classifies p as a corner if there exists\r\n   * a set of n contiguous pixelsin the circle which are all brighter than the\r\n   * intensity of the candidate pixel Ip plus a threshold t, or all darker\r\n   * than Ip − t.\r\n   *\r\n   *       15 00 01\r\n   *    14          02\r\n   * 13                03\r\n   * 12       []       04\r\n   * 11                05\r\n   *    10          06\r\n   *       09 08 07\r\n   *\r\n   * For more reference:\r\n   * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.3991&rep=rep1&type=pdf\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Fast = {};\r\n\r\n  /**\r\n   * Holds the threshold to determine whether the tested pixel is brighter or\r\n   * darker than the corner candidate p.\r\n   * @type {number}\r\n   * @default 40\r\n   * @static\r\n   */\r\n  tracking.Fast.THRESHOLD = 40;\r\n\r\n  /**\r\n   * Caches coordinates values of the circle surrounding the pixel candidate p.\r\n   * @type {Object.<number, Int32Array>}\r\n   * @private\r\n   * @static\r\n   */\r\n  tracking.Fast.circles_ = {};\r\n\r\n  /**\r\n   * Finds corners coordinates on the graysacaled image.\r\n   * @param {array} The grayscale pixels in a linear [p1,p2,...] array.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {number} threshold to determine whether the tested pixel is brighter or\r\n   *     darker than the corner candidate p. Default value is 40.\r\n   * @return {array} Array containing the coordinates of all found corners,\r\n   *     e.g. [x0,y0,x1,y1,...], where P(x0,y0) represents a corner coordinate.\r\n   * @static\r\n   */\r\n  tracking.Fast.findCorners = function(pixels, width, height, opt_threshold) {\r\n    var circleOffsets = this.getCircleOffsets_(width);\r\n    var circlePixels = new Int32Array(16);\r\n    var corners = [];\r\n\r\n    if (opt_threshold === undefined) {\r\n      opt_threshold = this.THRESHOLD;\r\n    }\r\n\r\n    // When looping through the image pixels, skips the first three lines from\r\n    // the image boundaries to constrain the surrounding circle inside the image\r\n    // area.\r\n    for (var i = 3; i < height - 3; i++) {\r\n      for (var j = 3; j < width - 3; j++) {\r\n        var w = i * width + j;\r\n        var p = pixels[w];\r\n\r\n        // Loops the circle offsets to read the pixel value for the sixteen\r\n        // surrounding pixels.\r\n        for (var k = 0; k < 16; k++) {\r\n          circlePixels[k] = pixels[w + circleOffsets[k]];\r\n        }\r\n\r\n        if (this.isCorner(p, circlePixels, opt_threshold)) {\r\n          // The pixel p is classified as a corner, as optimization increment j\r\n          // by the circle radius 3 to skip the neighbor pixels inside the\r\n          // surrounding circle. This can be removed without compromising the\r\n          // result.\r\n          corners.push(j, i);\r\n          j += 3;\r\n        }\r\n      }\r\n    }\r\n\r\n    return corners;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is brighter than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  tracking.Fast.isBrighter = function(circlePixel, p, threshold) {\r\n    return circlePixel - p > threshold;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is within the corner of the candidate pixel p\r\n   * by a threshold.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  tracking.Fast.isCorner = function(p, circlePixels, threshold) {\r\n    if (this.isTriviallyExcluded(circlePixels, p, threshold)) {\r\n      return false;\r\n    }\r\n\r\n    for (var x = 0; x < 16; x++) {\r\n      var darker = true;\r\n      var brighter = true;\r\n\r\n      for (var y = 0; y < 9; y++) {\r\n        var circlePixel = circlePixels[(x + y) & 15];\r\n\r\n        if (!this.isBrighter(p, circlePixel, threshold)) {\r\n          brighter = false;\r\n          if (darker === false) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!this.isDarker(p, circlePixel, threshold)) {\r\n          darker = false;\r\n          if (brighter === false) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (brighter || darker) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Checks if the circle pixel is darker than the candidate pixel p by\r\n   * a threshold.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   */\r\n  tracking.Fast.isDarker = function(circlePixel, p, threshold) {\r\n    return p - circlePixel > threshold;\r\n  };\r\n\r\n  /**\r\n   * Fast check to test if the candidate pixel is a trivially excluded value.\r\n   * In order to be a corner, the candidate pixel value should be darker or\r\n   * brighter than 9-12 surrounding pixels, when at least three of the top,\r\n   * bottom, left and right pixels are brighter or darker it can be\r\n   * automatically excluded improving the performance.\r\n   * @param {number} circlePixel The circle pixel value.\r\n   * @param {number} p The value of the candidate pixel p.\r\n   * @param {number} threshold\r\n   * @return {Boolean}\r\n   * @static\r\n   * @protected\r\n   */\r\n  tracking.Fast.isTriviallyExcluded = function(circlePixels, p, threshold) {\r\n    var count = 0;\r\n    var circleBottom = circlePixels[8];\r\n    var circleLeft = circlePixels[12];\r\n    var circleRight = circlePixels[4];\r\n    var circleTop = circlePixels[0];\r\n\r\n    if (this.isBrighter(circleTop, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleRight, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleBottom, p, threshold)) {\r\n      count++;\r\n    }\r\n    if (this.isBrighter(circleLeft, p, threshold)) {\r\n      count++;\r\n    }\r\n\r\n    if (count < 3) {\r\n      count = 0;\r\n      if (this.isDarker(circleTop, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleRight, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleBottom, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (this.isDarker(circleLeft, p, threshold)) {\r\n        count++;\r\n      }\r\n      if (count < 3) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Gets the sixteen offset values of the circle surrounding pixel.\r\n   * @param {number} width The image width.\r\n   * @return {array} Array with the sixteen offset values of the circle\r\n   *     surrounding pixel.\r\n   * @private\r\n   */\r\n  tracking.Fast.getCircleOffsets_ = function(width) {\r\n    if (this.circles_[width]) {\r\n      return this.circles_[width];\r\n    }\r\n\r\n    var circle = new Int32Array(16);\r\n\r\n    circle[0] = -width - width - width;\r\n    circle[1] = circle[0] + 1;\r\n    circle[2] = circle[1] + width + 1;\r\n    circle[3] = circle[2] + width + 1;\r\n    circle[4] = circle[3] + width;\r\n    circle[5] = circle[4] + width;\r\n    circle[6] = circle[5] + width - 1;\r\n    circle[7] = circle[6] + width - 1;\r\n    circle[8] = circle[7] - 1;\r\n    circle[9] = circle[8] - 1;\r\n    circle[10] = circle[9] - width - 1;\r\n    circle[11] = circle[10] - width - 1;\r\n    circle[12] = circle[11] - width;\r\n    circle[13] = circle[12] - width;\r\n    circle[14] = circle[13] - width + 1;\r\n    circle[15] = circle[14] - width + 1;\r\n\r\n    this.circles_[width] = circle;\r\n    return circle;\r\n  };\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Math utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Math = {};\r\n\r\n  /**\r\n   * Euclidean distance between two points P(x0, y0) and P(x1, y1).\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @return {number} The euclidean distance.\r\n   */\r\n  tracking.Math.distance = function(x0, y0, x1, y1) {\r\n    var dx = x1 - x0;\r\n    var dy = y1 - y0;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  };\r\n\r\n  /**\r\n   * Calculates the Hamming weight of a string, which is the number of symbols that are\r\n   * different from the zero-symbol of the alphabet used. It is thus\r\n   * equivalent to the Hamming distance from the all-zero string of the same\r\n   * length. For the most typical case, a string of bits, this is the number\r\n   * of 1's in the string.\r\n   *\r\n   * Example:\r\n   *\r\n   * <pre>\r\n   *  Binary string     Hamming weight\r\n   *   11101                 4\r\n   *   11101010              5\r\n   * </pre>\r\n   *\r\n   * @param {number} i Number that holds the binary string to extract the hamming weight.\r\n   * @return {number} The hamming weight.\r\n   */\r\n  tracking.Math.hammingWeight = function(i) {\r\n    i = i - ((i >> 1) & 0x55555555);\r\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\r\n\r\n    return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\r\n  };\r\n\r\n  /**\r\n   * Generates a random number between [a, b] interval.\r\n   * @param {number} a\r\n   * @param {number} b\r\n   * @return {number}\r\n   */\r\n  tracking.Math.uniformRandom = function(a, b) {\r\n    return a + Math.random() * (b - a);\r\n  };\r\n\r\n  /**\r\n   * Tests if a rectangle intersects with another.\r\n   *\r\n   *  <pre>\r\n   *  x0y0 --------       x2y2 --------\r\n   *      |       |           |       |\r\n   *      -------- x1y1       -------- x3y3\r\n   * </pre>\r\n   *\r\n   * @param {number} x0 Horizontal coordinate of P0.\r\n   * @param {number} y0 Vertical coordinate of P0.\r\n   * @param {number} x1 Horizontal coordinate of P1.\r\n   * @param {number} y1 Vertical coordinate of P1.\r\n   * @param {number} x2 Horizontal coordinate of P2.\r\n   * @param {number} y2 Vertical coordinate of P2.\r\n   * @param {number} x3 Horizontal coordinate of P3.\r\n   * @param {number} y3 Vertical coordinate of P3.\r\n   * @return {boolean}\r\n   */\r\n  tracking.Math.intersectRect = function(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Matrix utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.Matrix = {};\r\n\r\n  /**\r\n   * Loops the array organized as major-row order and executes `fn` callback\r\n   * for each iteration. The `fn` callback receives the following parameters:\r\n   * `(r,g,b,a,index,i,j)`, where `r,g,b,a` represents the pixel color with\r\n   * alpha channel, `index` represents the position in the major-row order\r\n   * array and `i,j` the respective indexes positions in two dimensions.\r\n   * @param {array} pixels The pixels in a linear [r,g,b,a,...] array to loop\r\n   *     through.\r\n   * @param {number} width The image width.\r\n   * @param {number} height The image height.\r\n   * @param {function} fn The callback function for each pixel.\r\n   * @param {number} opt_jump Optional jump for the iteration, by default it\r\n   *     is 1, hence loops all the pixels of the array.\r\n   * @static\r\n   */\r\n  tracking.Matrix.forEach = function(pixels, width, height, fn, opt_jump) {\r\n    opt_jump = opt_jump || 1;\r\n    for (var i = 0; i < height; i += opt_jump) {\r\n      for (var j = 0; j < width; j += opt_jump) {\r\n        var w = i * width * 4 + j * 4;\r\n        fn.call(this, pixels[w], pixels[w + 1], pixels[w + 2], pixels[w + 3], w, i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * EPnp utility.\r\n   * @static\r\n   * @constructor\r\n   */\r\n  tracking.EPnP = {};\r\n\r\n  tracking.EPnP.solve = function(objectPoints, imagePoints, cameraMatrix) {};\r\n}());\r\n\r\n(function() {\r\n  /**\r\n   * Glorious-Dawn: custom additional initialization   *\r\n   */\r\n  tracking.Fast.THRESHOLD=20;\r\n  tracking.Brief.randomWindowOffsets_=Int32Array.from([4,0,-7,-4,-2,5,4,7,2,-10,15,-11,6,-6,0,7,11,-9,-6,6,-5,14,9,-14,-9,-5,-6,-2,1,-1,13,-1,-2,-6,11,-10,-1,-11,-3,4,12,1,11,13,3,-13,7,8,3,14,-15,3,9,-2,10,-5,-1,3,10,7,13,-10,-8,1,-7,10,-11,8,-6,15,4,15,-4,6,14,-10,9,-5,0,11,-13,-7,-15,11,14,6,3,6,-3,-13,10,-3,-4,3,-8,12,-14,11,-14,1,-6,-2,3,14,10,14,4,13,10,15,2,5,1,1,9,-8,-10,13,-15,-9,-14,-7,9,7,-9,7,12,2,10,-14,7,0,-10,6,-15,-13,1,11,6,-8,8,-12,9,14,1,15,5,-10,2,3,9,8,-2,-4,13,-5,-8,0,-7,-3,13,-11,-7,10,13,-3,8,2,4,13,12,7,-6,4,15,1,-11,6,15,11,-5,-5,-1,-15,11,9,9,11,-5,-3,-7,-5,0,-8,1,-6,-4,-10,-5,1,0,15,15,-12,-11,-10,-6,12,10,-6,-8,0,6,-4,-7,-9,3,-9,-15,8,-7,-11,-2,7,-4,8,7,8,-3,5,4,-4,-9,4,5,-1,-7,-1,11,-5,-5,14,5,13,-14,13,6,-9,11,4,16,-7,-9,13,-15,-15,-2,10,-4,13,-11,15,11,6,10,-14,0,5,-12,1,-3,-10,0,3,10,-5,9,-9,10,1,-7,-13,-10,9,-5,-3,-4,-12,-13,-8,13,11,2,15,7,-9,-3,-5,0,13,12,2,-11,-8,-2,-9,14,-3,-11,8,-4,14,-4,12,4,-4,-13,5,3,2,4,-2,-6,-2,-5,14,3,-11,-1,2,-7,-6,-11,-7,11,3,-10,2,-11,14,8,-11,4,-2,4,3,1,-15,6,4,2,-4,0,0,4,-9,-8,11,3,-3,-11,-13,9,2,-8,3,15,15,0,7,-12,13,-4,5,10,-9,2,-2,-11,-5,-4,-5,-9,14,7,-2,-7,-2,10,-3,-1,2,-15,-13,14,8,-14,-10,-14,-14,5,13,-2,1,6,7,12,5,-2,-11,-7,-1,13,-9,10,16,-6,-12,4,-10,-8,-1,-13,16,6,8,-13,-4,13,1,-10,-6,13,-12,15,-5,-9,10,-3,4,7,2,-7,9,-1,7,-2,9,-5,2,11,1,12,-9,-5,-9,-5,9,-2,11,10,-11,-5,2,15,-9,-14,2,-15,-15,-6,14,-11,-3,-6,-6,-9,-9,-9,-13,12,-3,-14,-14,0,16,-12,6,0,-12,-12,15,-2,5,4,-1,-8,9,-5,-8,-6,-1,-12,15,-11,11,-9,9,-2,-15,-8,-5,-1,-12,4,-2,14,-10,8,-3,-13,3,-13,-5,15,2,14,9,-13,5,0,4,-8,4,7,5,3,-11,-3,2,6,0,-2,-11,1,13,-4,9,-2,-11,13,6,-2,-9,-2,1,14,4,15,12,12,3,8,15,-14,-6,16,-13,-10,-13,0,-13,-5,-2,-4,4,-2,14,-3,-4,5,14,9,0,14,12,9,14,7,-2,-12,12,-11,4,1,2,0,-9,-10,8,15,7,-10,10,13,-12,-6,10,2,15,3,15,5,0,-3,10,1,16,-2,-4,-3,13,13,2,8,-1,-5,15,5,1,3,11,-6,0,14,11,-2,-9,6,-5,11,10,-6,15,7,10,-9,-8,-10,-8,-15,-12,-9,6,-2,-14,8,5,4,-4,-4,14,-7,10,5,-14,-6,7,12,3,12,4,-3,-14,7,-8,-7,-1,3,4,-11,-12,10,12,-4,2,-15,-14,7,12,5,10,9,-14,-9,-12,-10,12,5,13,8,-13,2,-8,7,-8,5,-11,-1,5,4,-9,5,-12,-5,7,-2,8,0,10,16,-11,-4,-2,12,13,6,2,12,6,10,10,-6,-14,-4,-6,-7,-11,1,-12,-4,11,9,7,-1,6,-4,-11,3,-4,-5,-2,14,-14,-11,5,2,8,13,-11,13,6,-12,2,7,11,11,5,-4,7,-13,-9,10,0,-3,11,-8,-9,16,4,9,9,-14,9,-14,-1,-10,-7,-12,-6,12,3,-5,9,16,8,0,4,-6,12,13,15,14,9,9,-8,-13,1,12,-11,-2,10,9,-11,-9,4,13,15,-5,8,11,10,-10,-12,1,14,-9,2,-6,2,-9,12,-9,-4,-3,-6,-14,4,-11,-13,11,12,6,14,-12,15,-2,7,-15,1,4,-8,2,13,0,6,3,12,-4,-6,-8,7,14,0,-1,-3,-6,12,-2,-15,-4,-13,-11,8,-8,6,7,-2,-13,8,0,-5,-4,0,10,-13,10,5,16,-6,14,3,12,3,9,10,8,-1,0,-9,10,-6,9,11,6,13,3,9,15,9,-11,-2,6,7,-3,-13,16,4,-14,-7,-11,-11,6,9,-8,-15,-2,8,-7,3,15,3,5,-3,11,2,-15,8,10,-12,5,15,5,15,-1,3,-10,11,-5,7,-6,-5,-5,-7,-6,7,-6,14,13,-7,-2,-15,3,-13,-2,-8,-8,6,0,14,-15,12,-11,-1,1,-1,2,15,1,-11,4,-9,13,-6,12,5,8,-1,-8,-11,5,8,14,-4,5,3,-14,-1,-12,-11,-7,1,5,14,-8,3,-2,8,14,0,-7,-4,-4,12,0,10,1,-15,-14,10,-1,4,11,-12,-11,11,-4,8,-3,4,4,-10,10,-14,0,-12,15,-10,-8,4,-10,16,14,13,0,-4,-2,-9,-9,-1,2,16,11,8,-14,7,-7,8,-5,-5,5,5,-10,7,11,-5,8,-5,-11,0,-1,-11,10,6,8,-9,8,14,11,0,6,8,15,-3,-15,5,5,12,7,-13,-12,-1,0,16,5,-3,-7,0,10,8,-6,-2,8,-13,13,1,14,-5,1,2,-9,-13,3,-10,15,2,16,6,-8,15,-8,4,8,-5,-2,5,14,10,7,3,-6,-3,3,-13,-3,-14,1,-12,13,15,3,7,-9,4,-8,10,-13,-3,-3,-1,-6,-14,-11,-6,4,-11,12,-8,1,2,10,1,-2,-8,2,-13,14,1,4,0,8,15,-1,4,0,-7,-3,16,8,0,9,0,-4,-2,-2,7,4,-9,15,-7,14,2,-8,7,-13,-6,1,12,-8,-7,3,-2,13,-14,10,-14,2,-13,-1,-4,9,-3,15,-11,-6,10,-4,-14,-4,6,-3,-11,-9,-1,-7,3,-3,3,0,12,6,5,-10,10,-14,-12,-4,8,-7,11,5,15,14,-4,4,-5,-11,-7,1,-6,-13,-7,-12,10,13,-13,14,7,-13,-8,11,5,12,-6,-11,-13,-12,-5,12,13,-5,-5,-11,-2,6,8,-1,-10,6,6,14,3,5,3,-14,-12,1,-12,14,13,-4,10,7,13,-15,-8,-7,-14,8,12,-2,-15,10,12,-9,1,0,2,12,8,4,-10,-13,-12,-4,-9,16,-6,-4,-8,6,-6,-9,-10,2,1,6,3,-8,-6,1,6,13,16,-15,15,14,0,10,-5,16,11,-2,15,2,1,7,-6,-8,12,9,12,9,-9,-4,-11,-13,-14,3,1,-3,-11,13,-8,0,3,12,-4,6,15,1,-12,-4,14,-2,11,3,4,1,7,1,2,14,-5,-8,0,-3,-8,-4,-14,11,-12,-14,2,5,15,1,11,2,9,-15,9,4,6,-3,-5,-10,-9,-8,11,13,8,16,3,9,15,9,-1,-12,-2,-7,-10,-6,-7,15,-13,-13,6,6,11,14,-15,14,15,6,0,-7,-9,6,-5,-11,-12,-4,-11,-9,-1,-9,-14,16,16,3,-4,11,10,-3,13,-13,0,8,0,-6,13,-5,14,3,-10,-3,11,-9,8,-12,-8,12,5,-12,-13,5,-14,-8,-5,-12,-6,-12,0,1,-9,-5,7,2,11,-3,-6,7,0,9,-7,12,3,-7,15,4,1,-10,9,-12,-10,2,16,0,15,-14,-6,14,-3,-7,-8,4,-7,-6,-10,-1,-2,-10,13,14,0,-3,11,-6,-14,-11,6,7,-3,14,-15,7,-6,6,-8,-8,11,-1,10,-5,-14,16,-11,-6,-15,15,-14,-12,4,11,-9,-3,-3,-3,14,16,-15,13,13,10,5,14,6,-4,5,11,1,-15,8,4,0,-12,-3,4,12,14,3,-7,-4,1,14,13,-9,2,16,12,1,5,-4,3,13,-2,12,-11,-2,5,13,-3,2,14,-3,-3,0,0,-1,-9,2,-13,-3,-5,6,-6,15,12,2,-13,1,-6,-10,5,3,9,-14,-13,-5,-3,6,1,-8,12,-2,13,12,-13,-13,6,-11,5,-3,4,2,5,-13,-12,-8,-8,-7,-10,-3,-12,15,-8,2,14,-13,7,-4,10,-1,8,-10,1,4,16,11,8,13,7,-12,8,-11,7,-15,-3,-5,3,-6,-6,4,6,6,13,3,-8,3,2,-6,2,-3,5,-12,3,-2,4,8,-10,-8,-3,-1,-4,-8,6,-6,2,4,3,-9,5,12,-9,-1,2,13,-11,9,7,-8,5,12,-2,7,-2,3,-14,-2,-14,5,-12,-10,7,-8,-10,-6,13,12,-10,5,10,-9,-12,3,10,-6,-6,5,-5,-6,-9,1,-8,-15,1,-13,-3,6,10,3,1,15,-9,3,-4,16,13,-2,-12,13,-6,11,2,-4,10,-5,-2,-15,3,-11,-13,5,-5,16,-3,10,15,9,5,9,8,0,-3,3,5,14,0,8,15,10,9,11,6,-14,-10,3,-3,10,-2,-14,-14,-5,12,0,3,4,-3,2,-12,-7,12,-12,-2,-1,-11,6,3,9,9,-8,-11,14,-6,15,3,-7,2,-7,-10,11,-5,13,8,5,2,15,-5,-11,7,-8,-7,0,-1,-4,5,-7,1,14,1,11,12,7,4,0,-13,-10,-8,3,10,10,-13,-7,-15,-6,13,-1,-6,1,-2,12,-3,14,15,-10,5,9,-3,12,10,-1,0,14,6,-6,11,7,9,-11,-3,-13,11,-5,0,-7,-6,-9,-8,-1,-4,-14,-9,-2,16,14,-15,14,4,0,11,-13,12,2,6,14,0,3,12,13,12,-6,-10,-12,-3,0,10,-12,-12,-13,-10,-12,-10,-2,5,-6,-4,-11,-15,-14,-6,2,-10,12,1,15,16,-6,6,2,11,5,0,9,-4,16,-15,8,13,11,10,-1,14,11,-7,13,0,11,8,-4,-9,-14,14,-14,5,16,-15,11,-3,8,10,-14,9,-14,10,-14,10,6,-9,10,8,7,-9,-9,15,-14,0,14,8,-9,5,13,0,0,-7,0,-11,2,9,-8,7,-9,-7,13,-12,10,4,14,7,7,12,-15,16,-4,-14,-12,8,5,8,-4,12,1,2,-13,3,-4,-2,-5]);\r\n\r\n  // Used to eliminate the randomness when feature extractor needs to be stored and reused\r\n  tracking.Brief.setRandomWindowOffsets=function(windowOffsets){\r\n    this.randomImageOffsets_={};\r\n    this.randomWindowOffsets_=Int32Array.from(windowOffsets);\r\n  };\r\n\r\n  tracking.Brief.generateRandomWindowOffsets=function(){\r\n    var windowPosition = 0;\r\n    var windowOffsets = new Int32Array(4 * this.N);\r\n    for (var i = 0; i < this.N; i++) {\r\n      windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n      windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n      windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n      windowOffsets[windowPosition++] = Math.round(tracking.Math.uniformRandom(-15, 16));\r\n    }\r\n    return windowOffsets;\r\n  };\r\n\r\n}());\r\n\r\nmodule.exports=tracking;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default {\r\n    setRandomWindowOffsets:'$setRandomWindowOffsets',\r\n    setMainImageFeatures:'$setMainImageFeatures',\r\n    matchSubImageData:'$matchSubImageData',\r\n    matchSubImageFeatures:'$matchSubImageFeatures',\r\n    //TODO: optimize performance by batch processing to reduce messages, MatchWorker done.\r\n    matchSubImageFeaturesBatch:'$matchSubImageFeaturesBatch'\r\n};","import tracking from './tracking';\r\nimport Strings from \"../Strings\";\r\n\r\n/*\r\n* Training.\r\n* Fixed: targetImageFeatures, windowOffset\r\n* Input: subImages\r\n* Output: top 40 matches\r\n* Goal: Find the best windowOffset.\r\n*\r\n* Utilities: Generate targetImageFeatures from windowOffset and export(to local storage?)\r\n*\r\n* Debug: Descriptors calculated looks the same between extract Feature and matchImageDataInGrayscale\r\n*/\r\nlet mainImageCorners=[];\r\nlet mainImageDescriptors=[];\r\n\r\nfunction matchImageDataInGrayscale(imageDataA, imageDataB, threshold) {\r\n    let mainGray = tracking.Image.grayscale(imageDataA.data, imageDataA.width, imageDataA.height);\r\n    let mainCorners = tracking.Fast.findCorners(mainGray, imageDataA.width, imageDataA.height);\r\n    let mainDescriptors = tracking.Brief.getDescriptors(mainGray, imageDataA.width, mainCorners);\r\n    let subGray = tracking.Image.grayscale(imageDataB.data, imageDataB.width, imageDataB.height);\r\n    let subCorners = tracking.Fast.findCorners(subGray, imageDataB.width, imageDataB.height);\r\n    let subDescriptors = tracking.Brief.getDescriptors(subGray, imageDataB.width, subCorners);\r\n    let matches = tracking.Brief.reciprocalMatch(mainCorners, mainDescriptors, subCorners, subDescriptors);\r\n    if (threshold !== undefined)\r\n        matches = matches.filter(x => x.confidence >= threshold);\r\n    return matches\r\n}\r\n\r\nfunction extractFeature(imageData){\r\n    let grayscale = tracking.Image.grayscale(imageData.data, imageData.width, imageData.height);\r\n    let corners = tracking.Fast.findCorners(grayscale, imageData.width, imageData.height);\r\n    let descriptors = tracking.Brief.getDescriptors(grayscale, imageData.width, corners);\r\n    return descriptors\r\n}\r\n\r\nfunction matchFeatures(featureA,featureB,threshold){\r\n    let matches = tracking.Brief.reciprocalMatch(new Array(featureA.length/8), featureA,\r\n        new Array(featureB.length/8), featureB);\r\n    if (threshold !== undefined)\r\n        matches = matches.filter(x => x.confidence >= threshold);\r\n    return matches;\r\n    // const topN=10;\r\n    // matches.sort((a,b)=>b.confidence-a.confidence);\r\n    // matches=matches.slice(0,topN);\r\n    // let sum=0;\r\n    // for (let x of matches)\r\n    //     sum+=x.confidence;\r\n    // return sum/matches.length;\r\n}\r\n\r\nfunction matchOnMain(feature,threshold){\r\n    let matches = tracking.Brief.reciprocalMatch(mainImageCorners,mainImageDescriptors,\r\n        new Array(feature.length/(tracking.Brief.N/64)), feature);\r\n    if (threshold !== undefined)\r\n        matches = matches.filter(x => x.confidence >= threshold);\r\n    return matches.map(x=>x.keypoint1);\r\n}\r\n\r\nonmessage=function(e){\r\n    debugger;\r\n    const op=e.data[0];\r\n    let reply=[op];\r\n    if (op===Strings.setRandomWindowOffsets){\r\n        const windowOffset=e.data[1];\r\n        tracking.Brief.setRandomWindowOffsets(windowOffset);\r\n    }else if (op===Strings.setMainImageFeatures){\r\n        mainImageCorners=Int32Array.from(e.data[1]);\r\n        mainImageDescriptors=Int32Array.from(e.data[2]);\r\n    }else if (op===Strings.matchSubImageData){\r\n        const subImageId=e.data[1];\r\n        const subImageData=e.data[2];\r\n        const subImageFeatures=extractFeature(subImageData);\r\n        const matches=matchOnMain(subImageFeatures,0.8);\r\n        reply.push(subImageId);\r\n        reply.push(matches);\r\n        // reply.push(subImageFeatures);\r\n    }else if (op===Strings.matchSubImageFeatures){\r\n        const subImageId=e.data[1];\r\n        const subImageFeatures=Int32Array.from(e.data[2]);\r\n        const matches=matchOnMain(subImageFeatures,0.8);\r\n        reply.push(subImageId);\r\n        reply.push(matches);\r\n    }else if (op===Strings.matchSubImageFeaturesBatch){\r\n        const batchResult=[];\r\n        for (let x of e.data[1]){\r\n            const subImageId=x[1];\r\n            const subImageFeatures=x[2];\r\n            const matches=matchOnMain(subImageFeatures,0.8);\r\n            batchResult.push([subImageId,matches])\r\n        }\r\n        reply.push(batchResult);\r\n    }\r\n    postMessage(reply);\r\n};\r\n"],"sourceRoot":""}